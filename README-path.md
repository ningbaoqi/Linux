### 什么是环境变量
+ bash shell用一个叫做环境变量的特性来存储有关shell会话和工作环境的信息，这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问他们，这是存储持久数据的简单方法；
#### 全局环境变量
+ 全局环境变量对于shell会话和所有生成的子shell都是可见的；局部变量只对创建他们的shell可见； Linux系统在你开始bash会话时就设置了一些全局环境变量，系统环境变量基本上都是全大写字母，以区别普通用户的环境变量，你的登录方式会影响到所设置的环境变量；查看所有的全局环境变量可以使用：`env`、`printenv`；要显示个别环境变量的值可以使用printenv命令，但是不能使用env命令：`printenv 变量名` 如：`printenv HOME`；也可以使用echo显示变量的值：使用echo引用某个环境变量时，需要在变量前加一个美元符号$ 如：`echo $HOME($HOME 可以当做命令行参数 如 ls $HOME)`；
#### 局部环境变量
+ 局部变量只对创建他们的shell可见；显示某个特定进程的所有的环境变量（包括局部变量、全局变量、用户定义变量）：`set`；
### 设置PATH环境变量
+ 当你在shell命令行输入一个外部命令，shell必须搜索系统来找到对应的程序，PATH环境变量定义了用于进行命令和程序的查找的目录，如果命令或程序的位置没有包含在PATH中，如果不使用绝对目录的话，shell是没有办法找到的；应用程序放置可执行文件的目录常常不在PATH环境变量所包含的目录中，解决的办法是保证PATH环境变量包含了所有存放应用程序的目录；`echo $PATH`  就能查看；在PATH中添加路径：`PATH=$PATH:/HOME/DIR` 将/HOME/DIR添加在PATH中，添加完成就可以在虚拟目录结构中的任何位置执行程序；`PATH=$PATH:.  `将当前目录添加到PATH中；对PATH变量的修改只能持续到退出或重启系统，这种效果并不会一直持续；如果希望子shell也能找到你的程序的位置，一定要记住把修改后的PATH环境变量导出；
### 设置用户定义变量
#### 设置局部用户定义变量
+ 通过等号给环境变量赋值，值可以是数字和字符串，如果环境变量的值包含空格，必须使用双引号括起来（注：变量名、等号、变量值之间没有空格）：`my_variable=“hello world”（使用echo $my_variable就可以显示出来，现在使用该环境变量的值可以通过 $my_variable引用即可）`；用户定义的局部变量请使用小写，避免重新定义系统环境变量而带来的麻烦；设置局部变量之后，就能在该shell进程中使用它了，但是生成了一个另外的shell，他在子shell中不可用。如果在子进程中设置局部变量，一旦该子进程退出，该局部变量就不可用了；
#### 设置全局环境变量
+ 在设置全局环境变量的进程创建的子进程中，该变量可用；

|创建全局环境变量的步骤|
|------|
|先创建局部环境变量，然后将该局部环境变量导出到全局环境中|
|```my_variable=hello```|
|```export my_variable```|
+ 修改子shell中的全局环境变量并不会影响到父shell中该变量的值；尽管子shell重新定义并导出了变量my_variable，但父shell中的my_varibale变量依然保持原来的值；
